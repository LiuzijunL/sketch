INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (1, '移动web开发', '## 前端的前景是怎么样的 ##', '2018.12.24 16:28:50', '0', 1);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (3, 'vue day01', '### hello vue ###\r\n\r\nvue就是一个js文件而已\r\n\r\n1. 新建HTML页面, 引入vue.js文件\r\n\r\n		<script src=\"./lib/vue-2.4.0.js\"></script>\r\n\r\n2. 在页面中准备一个Vue的控制区域\r\n\r\n		<div id=\"app\"></div>	\r\n\r\n3. 创建Vue实例\r\n\r\n		var vm = new Vue({\r\n	      el: \'#app\',\r\n	      data: {\r\n	        hello: \'你好啊vuejs!\'\r\n	      }\r\n	    })\r\n\r\n4. 在app控制区域中使用vue的指令或者插值表达式将hello数据渲染到页面\r\n\r\n	插值表达式:\r\n\r\n		<div id=\"app\">\r\n			<p>\r\n				{{ hello }}\r\n			</p>\r\n		</div>\r\n\r\n	v-text:\r\n\r\n		<p v-text=\"hello\"></p>\r\n\r\n	v-html:\r\n\r\n		<p v-html=\"hello\"></p>\r\n\r\n	如果hello数据中有HTML标签, v-html会解析HTML标签, 而v-text会直接将其解析成纯文本输出\r\n\r\n\r\n### 基础指令 ###\r\n\r\n在vue中, 一切以 `v-` 开头的都是指令: directive\r\n\r\n\r\n插值表达式, Mustache语法也被称为小胡子语法:\r\n\r\n	{{ msg }}\r\n\r\n1. v-cloak\r\n\r\n	了解即可, 可以结合css解决插值表达式闪烁的问题, 让标签元素默认隐藏, v-cloak的特点是当数据渲染完成后自动显示\r\n\r\n2. v-text\r\n\r\n	将数据以**纯文本**的方式渲染到指定标签内部, 会直接覆盖标签内部的内容\r\n\r\n3. v-html\r\n\r\n	同v-text, 区别在于可以渲染**HTML标签**\r\n\r\n4. v-bind\r\n\r\n	做属性绑定的指令, 在标签中绑定title属性: 如果使用了属性绑定, 属性值就会被解析成JS表达式, 所以msg必须在vm实例的data中定义好, 否则会报错\r\n\r\n		<input v-bind:title=\"msg\" />\r\n\r\n	该指令使用非常频繁, 所以有简写形式 是 冒号  `:`\r\n\r\n		<input :title=\"msg\" />\r\n\r\n	而且v-bind可以绑定原生的dom属性, 也可以绑定自定义属性\r\n\r\n5. v-on\r\n\r\n	做事件绑定的指令, 简写形式 是 艾特符号 `@`\r\n\r\n		<input @mouseover=\"clickHandler\" v-on:click=\"clickHandler\" />\r\n\r\n	`clickHandler`必须在vue实例的 methods 节点中定义\r\n\r\n		var vm = new Vue({\r\n	      el: \'#app\',\r\n	      methods: {\r\n	        clickHandler() {\r\n	          console.log(\'秀!\')\r\n	        }\r\n	      }\r\n	    })\r\n\r\n	如果需要绑定其他事件, 将click换成其他事件名即可\r\n\r\n6. v-model\r\n\r\n	**注意: 这是唯一一个实现双向数据绑定的指令, 而且只能用于表单元素, 不需要指定属性, 只能绑定value属性**\r\n\r\n		<input type=\"text\" style=\"width:100%;\" v-model=\"msg\">\r\n\r\n	如果双向数据绑定, 一定要先在data中定义好msg\r\n\r\n### 事件修饰符 ###\r\n\r\n事件修饰符在事件绑定时, 加在事件名后面\r\n\r\n	<input @click.stop=\"roll\" type=\"button\" value=\"动起来\">\r\n\r\n事件修饰符可以串联加多个\r\n\r\n	<input @click.stop.prevent=\"roll\" type=\"button\" value=\"动起来\">\r\n\r\n1. 阻止冒泡\r\n\r\n	.stop\r\n\r\n2. 阻止浏览器默认行为\r\n \r\n	.prevent\r\n\r\n3. 使用捕获, 等同于 `addEventListener()` 第三个参数传入true的效果\r\n\r\n	.capture\r\n\r\n4. 只有点击当前元素自身才会触发事件, 如果通过冒泡或者捕获传递过来的事件不会触发\r\n\r\n	.self\r\n\r\n5. 只触发一次\r\n\r\n	.once\r\n\r\n6. 在移动端使用scroll事件时建议加上, 可以提高性能\r\n\r\n	.passive', '2018.12.28 10:12:35', '0', 4);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (4, '真正厉害的人都懂得慢慢来', '最近追完的一部剧《橙红年代》，里面最触动我的一个场景就是：男主角刘子光为了逃出毒枭基地，一开始是找机会就逃，结果无数次被暴打然后拎回来。后来，他终于学会“慢慢来”，在黑暗中隐忍，在黑暗中磨练自己的体力，在黑暗中用眼睛观察毒贩们怎样练体力、怎样用枪，然后一个人在黑暗中练习千万遍……他逃跑间隔的时间越来越长，成功率却越来越大，终于在最后一次天时地利人和的情况下，成功！今天这个题目，只有三个字：慢慢来。我思考写什么，却至少已经有三天了。前几天，只是把这事儿放在潜意识里，而今天是007交作业的最后期限，说实话，我思考一天未果，尤其从五点班级群里面作业雨开始以后到十点半提笔之前，一直很焦急。逼着自己不停地输入，听得到、读文章、思考再思考……把这个想话题的过程也记录下来，是因为我觉得这件事蛮有趣的，或许还能跟一些童鞋有共鸣之处可以交流一下，下次别把自己搞得这么挠心。我还发现，我特别焦急地想写些什么，越急，越找不到。反而到最后，我放弃寻找，让自己投入当下正在读的文章时，我却很自然很顺利地找到了切入口。哎，要慢慢来，这也是我想写这个话题的引子。只是为了及时交作业，这一个小的任务，我就把自己逼的急功近利了，逼的焦虑了，然后效率就低了……人生中那些大事，何尝不是如此？想一想，我们现代人多么容易焦虑？不就是因为偶尔看到一条新闻，一个比你年轻、跟你差不多出身的人，突然就比你成功了。你先是愤愤不平，进而自我怀疑，然后就开始焦虑了，开始怀疑人生，开始不知所措，开始病急乱投医，给自己买课报班，喝上N碗鸡血，制定打卡计划，设置各种梦想清单……然后，打卡三天，开始懈怠，打卡一周感觉看不到变化，打卡十天准备放弃……然后在打卡两周之前放弃了……放纵自我两三天，继续开始新一轮的羡慕嫉妒、自我怀疑、焦虑、鸡血……我想说，亲，淡定，别那么急功近利可好？很多人会感慨，为啥有那么多持续自律的高手啊，为什么我做不到啊？其实，不是你做不到，只是你不懂得慢慢来。比如有的人只写了三五篇文章，看到阅读数不多、没有人点赞，就会自我怀疑了：我是不是没有写作天赋？少年，你太急功近利了！麻烦你先写上个一百篇再考虑天赋问题可好？我们都懂得付出才有收获的道理，但是做事的时候，却往往急于求成，因为这个社会“成功人士的好消息”太多了，我们人类又天生爱跟别人比。但是很多时候，这些消息只报道了人前的光彩，又有多少研究了背后的细节？比如近几年靠自媒体写作走出的一批牛人，简书人都熟悉的猫叔、小六，他们是写了三五篇文章就火起来的吗？绝对不是啊，他们不但有大量的写作，更有大量的积累，不止有读书、还有见牛人，不止有输入输出，还有无数次战略层面和操作层面的反思和调整……有什么事，短短十天甚至两三天就能立竿见影呢？如果有，那么这件事的价值估计也不大。比如，我坚持早起185天了，都还没发现早起给我带来太大改变，你只坚持了两周，就想要因为早起变得多牛多优秀吗？再举个减肥的例子，交代一下，我是专业做减肥和养生的，有的减肥顾客刚用了两天，就着急：为什么我才减了几两呢？为什么我的体脂率还没降低呢？我想说，你是一天吃胖的吗？再好的减肥产品也不是割肉机，何况任何一种健康的减肥方式，都需要符合我们身体的规律，一天减三四斤那种减肥药，我反而觉得挺可怕。再说，身体都是有记忆的，全身细胞的代谢需要90-180天，即使一周减了十斤，也需要保持这个记录90天以上，才能不反弹。真正厉害的人，都懂得慢慢来。他们不急，他们深刻理解“量变积累到一定程度就会引起质变”的哲理。他们很淡定地坚持着一件小事、两件小事……然后，这一件件小事，慢慢成就了一个又一个不凡的成绩，这一个个成绩又奠定了他们人生质变的基石，直到成为下一个刺激你焦虑的“成功人物”。所以，如果你真正想做成一件事，慢慢来吧。\r\n\r\n作者：无敌\r\n链接：https://www.jianshu.com/p/8a5e8cad30a5\r\n來源：简书\r\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。', '2018.12.28 20:02:48', '0', 5);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (5, 'node day01', '### node的简介 ###\r\n\r\n- 前后端分离:\r\n\r\n	前端负责写页面, 和发送ajax请求获取数据, 通过模板引擎进行渲染\r\n	\r\n	后端负责写接口, 提供数据\r\n\r\n- node环境的JavaScript\r\n\r\n	不同于浏览器中js, 不存在DOM和BOM的概念\r\n\r\n	以前所说的js的组成: ECMAScript + BOM + DOM, 其实是指在浏览器中JS的组成\r\n\r\n		document.getElementById() // DOM中的方法\r\n		var arr = []\r\n		arr.sort() // ECMAScript中规范的方法\r\n\r\n	共同点: 只要是js, 都会遵循ECMAScrit规范\r\n\r\n	node环境的js组成: ECMAScript + 全局成员 + 内置模块 + 第三方模块\r\n\r\n	npm: node package manager (node包管理器)\r\n\r\n- 使用node运行js\r\n\r\n	打开终端(Windows控制台) , cmd\r\n\r\n### ES6新语法 ###\r\n\r\n1. let关键字\r\n\r\n	由于JS历史遗留问题, 声明变量一直使用var关键字, 特点就是有变量声明提升, 没有块级作用域\r\n\r\n	let关键字的出现就是为了解决上述两个问题, 特点如下:\r\n\r\n	a. let声明变量必须声明后才可以使用, 如果在声明之前使用变量会直接报错: xxx is not defined\r\n\r\n	b. let声明变量不赋值, 默认值也是undefined\r\n\r\n	c. let声明的变量有块级作用域, 如果在if/while/for等有大括号的代码中声明变量, 出了这个大括号就无法访问了\r\n\r\n	d. let和const都无法重复声明变量, 一旦变量被声明就不可再次声明\r\n\r\n2. const关键字\r\n\r\n	不同于let的是, const用于声明常量, 一旦被声明必须立即赋值, 并且永远不可修改\r\n\r\n	a. const声明的常量必须立即赋值\r\n\r\n	b. 不可被再次修改\r\n\r\n	c. 其他地方同let\r\n\r\n3. 解构赋值\r\n\r\n	作用: 将对象的属性提取出来存在变量中, 例如, 将userInfo对象的name和age属性提取出来放到name和age变量中存储:\r\n\r\n		let userInfo = {\r\n			name: \'谢俊\',\r\n			age: 30,\r\n			gender: \'男\',\r\n			sayHi: function() {\r\n				console.log(\'大家好我是\' + this.name)\r\n			}\r\n		}\r\n		// 以前的做法:\r\n		// let name = userInfo.name\r\n		// let userAge = userInfo.age\r\n		// let sayHi = userInfo.sayHi\r\n		// sayHi()\r\n		// ES6解构赋值的做法:\r\n		let { name, age: userAge, sayHi } = userInfo\r\n		// 以上代码只是将用户信息的属性值提取出来存到变量中了, 如果修改变量name或userAge, 不会影响userInfo中的数据, 因为这是基本数据类型, 传递数据都是值传递\r\n\r\n4. 箭头函数\r\n\r\n	作用: 为了解决函数内部this指向的问题, 箭头函数的特点就是, 函数内部的this永远指向函数外部的this\r\n\r\n	语法:\r\n\r\n		// 小括号里面写形参列表\r\n		// 大括号里面写函数体\r\n		() => {}\r\n\r\n	简便写法:\r\n\r\n	a. 如果形参列表只有一个参数, 可以省略小括号, 注意: 如果一个参数都没有或者两个以上的参数必须加上小括号`()`\r\n\r\n	b. 如果函数体中只有一行代码, 那么右侧的大括号`{}`可以省略, 并且还需要去掉return关键字, 默认会把这一行代码执行的结果返回出去\r\n\r\n5. 添加对象属性或方法的简便写法\r\n\r\n	作用: 把和对象属性同名的变量快速的添加到对象中\r\n\r\n	以前的写法\r\n\r\n		let name = \'谢俊\'\r\n		let age = 30\r\n		\r\n		let obj = {\r\n		  name: name,\r\n		  age: age\r\n		}\r\n\r\n	ES6的写法:\r\n\r\n		let name = \'谢俊\'\r\n		let age = 30\r\n		let fn = function () {\r\n		  console.log(\'我是fn\')\r\n		}\r\n		\r\n		let obj = {\r\n		  name,\r\n		  age,\r\n		  fn,\r\n		  sayHi() {\r\n		    \r\n		  }\r\n		}\r\n\r\n\r\n### fs模块 ###\r\n\r\nfs模块属于核心模块, 只要安装了node环境就会携带, 使用方法先导入该模块:\r\n\r\n	const fs = require(\'fs\')\r\n\r\n1. 读取文件\r\n\r\n		fs.readFile()\r\n\r\n	参数1: 路径 path, 可以是相对路径\r\n\r\n	参数2: 可选值 编码\r\n\r\n	参数3: 读取完成的回调函数, 该回调函数中有两个参数, 第一个是错误信息err, 第二个是读取的数据data, 如果没有指定编码, data是Buffer类型的数据, 可以通过toString转为字符串\r\n\r\n2. 写入文件\r\n\r\n		fs.writeFile()\r\n\r\n	参数1: 路径\r\n\r\n	参数2: 要写入的数据, 类型可以是string或buffer\r\n\r\n	参数3: 可选值 编码 默认utf-8\r\n\r\n	参数4: 回调函数, 该回调函数只有一个参数错误信息err\r\n\r\n	**注意: 如果要写入的文件不存在, 会创建文件后写入**\r\n\r\n3. 追加文件\r\n\r\n		fs.appendFile()\r\n\r\n	参数1: 路径\r\n\r\n	参数2: 要追加的数据, 类型可以是string或buffer\r\n\r\n	参数3: 可选值 编码 默认utf-8\r\n\r\n	参数4: 回调函数, 该回调函数只有一个参数错误信息err\r\n\r\n	**注意: 如果要追加的文件不存在, 会创建文件后追加**\r\n\r\n\r\n4. 复制文件\r\n\r\n		fs.copyFile()\r\n\r\n	参数1: 源路径\r\n\r\n	参数2: 目标路径\r\n\r\n	参数3: 可选值 flags 无视掉\r\n\r\n	参数4: 回调函数, 该回调函数只有一个参数错误信息err', '2018.12.28 20:13:37', '0', 1);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (6, 'node day02', '### node.js的简介 ###\r\n\r\n- node.js是什么?\r\n\r\n> 它不是一个新的语言, 也不是一个JS库, 它是一个内置了V8解析引擎的JavaScript运行时环境, 可以在node平台上直接运行js代码\r\n\r\n- node.js的特点?\r\n\r\n> node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效, 单线程, 异步\r\n\r\n> 事件驱动: 如同前端开发时一样, 我们的开发都是伴随着用户的交互完成的, 最终目的是为了和用户实现交互, 例如: 当用户点击按钮时, 我们处理某些业务逻辑. node.js也一样, 一切的操作都是由事件来驱动的, 例如: 当有客户端来请求时我们做出对应的响应\r\n\r\n> 非阻塞式I/O: IO是指 input / output 输入输出, 一般泛指读写, 读写包括了文件读写, 网络读写. 非阻塞式是指, 如果有多个读写任务同时执行, 不会依次等待前面执行完后再执行后面, 而是将一个个读写任务放到任务队列中等待调度执行  拿票取餐\r\n\r\n> 同理, 阻塞式IO就是指, 如果三个读写任务同时执行, 必须依次有顺序的进行, 第一个不读写完成, 无法继续读写第二个 嗨大米\r\n\r\n> 单线程是指永远只有一条线程运行代码, 通俗的理解就是代码永远都由一个人负责执行\r\n\r\n- 多线程对比单线程?\r\n\r\n> 在大部分情况下(并发量较高), 多线程的性能肯定是优于单线程的\r\n\r\n> 多线程的优势在于性能, 但是缺点在于数据同步问题, 如何解决? 加锁, 当一条线程在操作数据时, 其他现场必须等待, 执行完毕后才能继续下一条线程执行\r\n\r\n- JS为什么是单线程?\r\n\r\n> 因为js早期设计出来是应付前端开发, 操作DOM元素的, 如果使用多线程会出现一种情况: A线程说将DIV隐藏, B线程说将DIV显示, 最后结果不确定. 所以正因为多线程同时操作页面, 随机性太强了, 而且没有意义, 最后直接将js设计成了单线程\r\n\r\n> 在Android开发中也是同理, 但是由于Android开发是Java语言进行的, 而Java是多线程语言, Android不得不做一个处理, 规定了一个主线程, 也被称为UI线程, 只能在该线程中操作UI, 如果在子线程操作UI 直接报错\r\n\r\n### __dirname ###\r\n\r\n在node中直接使用相对路径会出问题, 因为相对路径不是相对于当前文件所在路径, 而是相对于node指令执行的所在路径\r\n\r\n	fs.readFile(\'./files/4.txt\', (err, data) => {\r\n	  if (err) return console.log(err.message)\r\n	  console.log(data.toString())\r\n	})\r\n\r\n在控制台执行 `node __dirname文件读取.js`\r\n\r\n可以正常读取到文件内容:\r\n\r\n	C:\\Users\\LTC\\Desktop\\22期\\课堂代码\\nodeday01>node __dirname文件读取.js\r\n	﻿aa\r\n	ANSI是指操作系统平台的编码\r\n	\r\n	Windows默认是GBK\r\n	\r\n	Linux/Unix 默认是UTF-8\r\n	\r\n如果返回到上一级目录, 或者其他目录再去执行代码:\r\n\r\n	C:\\Users\\LTC\\Desktop\\22期\\课堂代码\\nodeday01>cd ..\r\n\r\n	C:\\Users\\LTC\\Desktop\\22期\\课堂代码>node nodeday01\\__dirname文件读取.js\r\n	ENOENT: no such file or directory, open \'C:\\Users\\LTC\\Desktop\\22期\\课堂代码\\files\\4.txt\'\r\n\r\n通过以上执行结果可以证明, 在node中执行相对路径是相对于`node`指令运行的目录\r\n\r\n如何解决该问题?\r\n\r\n我们希望相对于当前js文件所在的路径去写代码, 就需要利用`__dirname`全局成员完成绝对路径的拼接\r\n\r\n	__dirname // 获取当前js文件所在的绝对路径\r\n\r\n打印输出 `__dirname` 的值\r\n\r\n	console.log(__dirname)\r\n\r\n执行代码:\r\n\r\n	C:\\Users\\LTC\\Desktop\\22期\\课堂代码>node nodeday01\\__dirname文件读取.js\r\n	C:\\Users\\LTC\\Desktop\\22期\\课堂代码\\nodeday01\r\n\r\n既然已经获取到绝对路径, 最后只需要进行字符串拼接即可完成路径操作:\r\n\r\n	fs.readFile(__dirname + \'/files/4.txt\', (err, data) => {\r\n	  if (err) return console.log(err.message)\r\n	  console.log(data.toString())\r\n	})\r\n\r\n现在, 该代码在任何目录下执行都是指读取当前文件所在的目录下的files目录的4.txt\r\n\r\n执行代码:\r\n\r\n	C:\\Users\\LTC\\Desktop\\22期\\课堂代码>node nodeday01\\__dirname文件读取.js\r\n	﻿aa\r\n	ANSI是指操作系统平台的编码\r\n	\r\n	Windows默认是GBK\r\n	\r\n	Linux/Unix 默认是UTF-8\r\n\r\n### __filename ###\r\n\r\n不同于__dirname, 获取的是当前js文件的完整路径, 包括文件名, 所以不常用 了解即可\r\n\r\n### fs.stat() ###\r\n\r\n作用: 用于获取文件或目录的状态(属性)信息\r\n\r\n用法:\r\n\r\n	fs.stat(__dirname + \'/files/4.txt\', (err, stats) => {\r\n 		stats // 表示获取到的数据信息对象\r\n	})\r\n\r\n结果stats中具有的属性如下:\r\n\r\n	Stats {\r\n	  dev: 2114,\r\n	  ino: 48064969,\r\n	  mode: 33188,\r\n	  nlink: 1,\r\n	  uid: 85,\r\n	  gid: 100,\r\n	  rdev: 0,\r\n	  size: 527,\r\n	  blksize: 4096,\r\n	  blocks: 8,\r\n	  atimeMs: 1318289051000.1,\r\n	  mtimeMs: 1318289051000.1,\r\n	  ctimeMs: 1318289051000.1,\r\n	  birthtimeMs: 1318289051000.1,\r\n	  atime: Mon, 10 Oct 2011 23:24:11 GMT,\r\n	  mtime: Mon, 10 Oct 2011 23:24:11 GMT,\r\n	  ctime: Mon, 10 Oct 2011 23:24:11 GMT,\r\n	  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }\r\n\r\n还具备一些方法, 详见官方文档: [http://nodejs.cn/api/fs.html#fs_class_fs_stats](http://nodejs.cn/api/fs.html#fs_class_fs_stats \"http://nodejs.cn/api/fs.html#fs_class_fs_stats\")\r\n\r\n### path模块 ###\r\n\r\n唯一需要掌握的方法: **path.join()**\r\n\r\n作用: 用于拼接路径片段, 例如: \r\n\r\n	path.join(\'c:\\\', \'xxx\', \'./qqq\', \'../rrr\')\r\n\r\n	// c:\\xxx\\rrr\r\n\r\n结合 `__dirname` 使用:\r\n\r\n	path.join(__dirname, \'../files\') // 查找当前js文件所在目录的上一级目录中的files路径\r\n\r\n其他方法:\r\n\r\n	path.basename() // 文件名\r\n	path.dirname() // 文件所在的路径\r\n	path.extname() // 扩展名\r\n\r\n### 模块化 ###\r\n\r\n为了提高软件工程的后期可维护性, 代码的复用性, 降低查找Bug的难度\r\n\r\n模块化该如何实现:\r\n\r\n靠明文的规范, 例如前端模块化: AMD/CMD\r\n\r\nnode中模块化遵循的是 CommonJS 规范:\r\n\r\n	require() 就是CommonJS规范中导入模块的方式\r\n\r\n为什么浏览器中不使用CommonJS规范?\r\n\r\n因为 CommonJS 是同步加载模块\r\n\r\n### CommonJS规范 ###\r\n\r\nCommonJS有以下3点规范:\r\n\r\n1. 模块内部必须有require成员, 而且是一个函数, 用于导入其他模块\r\n2. 模块内部必须有exports成员, 是一个对象, 用于向外暴露模块\r\n3. 模块内部必须有module成员, 是一个对象, 表示当前模块\r\n\r\n作用域:\r\n\r\n每个js文件就是一个模块, 不同的模块之间作用域互不共享, 这种作用域被称为: **模块作用域**\r\n\r\n在Node中也有全局作用域, 每个js文件都可以直接访问 global对象, 该对象就是全局对象, 但是开发中一般不会挂载全局成员, 为了避免 全局作用域的污染\r\n\r\n模块之间暴露成员:\r\n\r\nexports可以进行成员暴露, 但是不推荐, 因为exports只是node帮我们简化书写处理了一下, 是一个变量, 该变量记录了module.exports的值 类似于:`let exports = module.exports`\r\n\r\nCommonJS暴露成员永远都以 `module.exports` 为主, 如果整个代码运行完毕, exports和module.exports指向同一个对象, 则不会出任何问题, 但是一旦当exports或module.exports修改了指向, 始终以module.exports为准, 所以总结如下:\r\n\r\n**任何情况下都使用 module.exports**\r\n\r\n### 包的规范 ###\r\n\r\n1. 一个包必须放在一个目录下, 该目录必须由英文小写, 多个单词用`-`连接, 不能以数字开头\r\n\r\n2. 包的根目录下必须有一个 `package.json`, 该文件中必须包含最少以下三个属性:\r\n\r\n		name, version, main\r\n\r\n	但是不需要刻意的记忆以上三个属性, 在当前包的根目录下执行以下指令可以一键生成package.json文件:\r\n\r\n		npm init -y', '2018.12.28 20:15:40', '0', 1);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (7, 'vue day02', '1. 创建对象的方式:\r\n\r\n		// 对象字面量\r\n		var obj = {} // new Object()\r\n		\r\n		// 数组字面量\r\n		var arr = [] // new Array()\r\n		\r\n		// 正则字面量\r\n		var regex = /\\w+/ // new RegExp()\r\n		\r\n		// 使用Object构造函数创建对象\r\n		var obj2 = new Object()\r\n		\r\n		// 自定义工厂函数创建对象\r\n		var obj3 = createObj(\'zs\')\r\n		\r\n		function createObj(name) {\r\n			return {\r\n				name: name\r\n			}\r\n		}\r\n		\r\n		// 自定义构造函数创建对象\r\n		var obj4 = new Student(\'ls\')\r\n		\r\n		function Student(name) {\r\n			this.name = name\r\n		}\r\n		\r\n		// 判断对象的类型, typeof判断对象永远都是 \'object\'\r\n		console.log(typeof obj4) // \'object\'\r\n		\r\n		// instanceof 判断对象的具体类型\r\n		// instanceof 判断依据 是看对象是否在 该构造函数的原型链上\r\n		// A instanceof B 就是看B是否在A的原型链上\r\n		console.log(obj4 instanceof Student) // true\r\n		console.log(obj4 instanceof Object) // true\r\n\r\n	总结: 创建对象 永远都离不开 构造函数, 最终一定是 new 构造函数创建出来的对象, 所以不存在几种创建对象的方式, 只有一种, 就是通过构造函数创建对象\r\n\r\n2. 闭包\r\n\r\n	函数内部包含一个函数, 在内部函数中访问了外部函数中的局部成员\r\n\r\n		function outer() {\r\n			var a = 10\r\n			function inner() {\r\n				// 在下面这行代码执行时就会产生 closure 闭包空间\r\n				var b = a + 20\r\n			}\r\n			return inner\r\n		}\r\n\r\n		outer()()\r\n\r\n	在开发中尽量减少使用闭包, 因为闭包一定会导致内存泄漏\r\n\r\n	内存泄漏: 本该被释放的内存, 没有被释放\r\n\r\n3. 事件委托(事件代理)\r\n\r\n	> 一般用在动态创建元素还需要绑定事件时\r\n\r\n	> 因为直接绑定事件, 页面加载时就会绑定一次, 但是动态添加的元素就无法被绑定事件了, 而事件委托的原理是依赖于事件冒泡, 也就是说事件被绑定在父元素身上, 如果将来有新加入的子元素也会响应事件\r\n\r\n### 设置类样式 ###\r\n\r\n总结来说使用属性绑定的方式设置样式, 一般就是设置 对象 或 数组\r\n\r\n1. 设置一个数组\r\n\r\n	适合同时设置多个固定样式 (一般不用)\r\n\r\n		<h1 :class=\"[\'red\', \'thin\']\">这是一个很大很大的H1，大到你无法想象！！！</h1>\r\n\r\n	如果其中某些**样式需要动态切换**, 根据标记切换\r\n\r\n	在js中属性名如果是合法的变量名, 可以不用加引号, 以下代码表示h1固定样式是red和thin, active样式是根据flag的true或false动态切换\r\n\r\n	flag需要在data中定义\r\n\r\n		<h1 :class=\"[\'red\', \'thin\', { active: flag }]\">这是一个很大很大的H1，大到你无法想象！！！</h1>\r\n\r\n	此方式适合多个固定样式结合少量动态切换的样式使用\r\n\r\n2. 设置一个对象\r\n\r\n	适合多个动态切换的样式, 少部分固定样式使用, 因为固定样式也需要手动加上true, 不如直接用数组来设置样式\r\n\r\n		<h1 :class=\"{ red: true, thin: false, active: true }\">这是一个很大很大的H1，大到你无法想象！！！</h1>\r\n\r\n3. 使用字符串拼接动态操作类样式 (**不推荐!!!**)\r\n\r\n	因为字符串操作容易出现问题, 所以尽量不要使用字符串拼接的方式去动态修改类样式\r\n\r\n		<h1 :class=\"\'active red\' + (flag ? \' thin\' : \'\')\">这是一个很大很大的H1，大到你无法想象！！！</h1>\r\n\r\n### 设置行内样式 ###\r\n\r\n将样式对象挂载到data节点中:\r\n\r\n	var vm = new Vue({\r\n      el: \'#app\',\r\n      data: {\r\n        styleObj1: { color: \'red\', \'font-weight\': 200 },\r\n        styleObj2: { \'font-style\': \'italic\' }\r\n      },\r\n      methods: {}\r\n    })\r\n\r\n1. 设置一个对象(比较常用)\r\n\r\n		<h1 :style=\"styleObj1\">这是一个h1</h1>\r\n\r\n2. 设置一个数组 (数组中放多个样式对象, 可以合并)\r\n\r\n		<h1 :style=\"[ styleObj1, styleObj2 ]\">这是一个h1</h1>\r\n\r\n### v-for 列表渲染 ###\r\n\r\n准备渲染的数据:\r\n\r\n	var vm = new Vue({\r\n      el: \'#app\',\r\n      data: {\r\n        list: [1, 2, 3, 4, 5, 6],\r\n		users: [\r\n          { id: 1, name: \'zs1\' },\r\n          { id: 2, name: \'zs2\' },\r\n          { id: 3, name: \'zs3\' },\r\n          { id: 4, name: \'zs4\' }\r\n        ],\r\n		user: {\r\n          id: 1,\r\n          name: \'托尼·屎大颗\',\r\n          gender: \'男\'\r\n        }\r\n      }\r\n    })\r\n\r\n1. 渲染普通数组\r\n\r\n		<p v-for=\"(item, index) in list\">\r\n			每一项: {{ item }}\r\n			索引: {{ index }}\r\n		</p>\r\n\r\n2. 渲染对象数组\r\n\r\n		<p v-for=\"(user, index) in users\">\r\n			用户ID: {{ user.id }}\r\n			用户名: {{ user.name }}\r\n			索引: {{ index }}\r\n		</p>\r\n\r\n3. 渲染对象\r\n		\r\n		<p v-for=\"(val, key) in user\">\r\n			键: {{ key }}\r\n			值: {{ val }}\r\n		</p>\r\n\r\n4. 迭代数字\r\n\r\n	item从1开始到20结束, 如果要当成索引用, 可以手动 -1\r\n\r\n		<p v-for=\"item in 20\">\r\n			{{ item }}\r\n		</p>\r\n\r\n### v-for 中的 key 属性 ###\r\n\r\n- 结论: 除非使用的列表非常简单, 或者追求极致的性能体验, **都建议在使用v-for时加上 key 属性**\r\n\r\n- 原理: 由于使用v-for渲染列表时, vue不会记录每个列表项和数据之间的关系, 都是统一按照索引进行渲染的, 如果此时有一个复选框表单元素被勾选, 然后将新的元素插入到列表的前面, 导致整个列表顺序发生变化, 那么复选框也会跟随索引而勾选 不会跟随数据勾选\r\n\r\n- 解决方式: 在使用v-for时加上 :key 属性绑定, 绑定的值为每项数据的唯一标识, 而且数据类型必须是number / string 一般都用id作为唯一标识, 如果没有id时也可以使用索引 实在不行用name也行\r\n\r\n### v-if 和 v-show ###\r\n\r\n- v-if和v-show都是用于控制元素的显示隐藏\r\n- v-if有较高的切换渲染消耗\r\n- v-show有较高的初始渲染消耗\r\n\r\n总结: 如果需要频繁的切换显示隐藏推荐使用v-show, 如果只需要一次切换, 或者一次都没有, 则使用v-if', '2018.12.29 09:31:55', '0', 1);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (8, 'の41去问问企鹅且请问', '去问问企鹅请问去恶趣味去我去', '2018.12.30 16:31:01', '0', 6);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (9, '阳仔', '阳仔你在吗？\r\n在的话 我要开始传文件了', '2018.12.30 16:38:59', '0', 8);
INSERT INTO `articles` (`id`, `title`, `content`, `ctime`, `praise`, `authorId`) VALUES (10, '今天是18年12月30号,还有一天都结束了2018,你有什么想说的吗!', '**明年就是本命年啦,希望大家都身体健康,工作顺利,一帆风顺**\r\n', '2018.12.30 16:43:49', '0', 7);
